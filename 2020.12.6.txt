复用类:(在开始一个设计时，一般应优先选择组合，必要的时候才用继承)
使用类而不破坏现有程序代码,有两种达到这一目的的方法:
1.组合:在新的类中产生现有类的对象,也就是说new一个对象
2.继承:照现有类的类型来创建新类,不改变现有类的形式,在其基础上添加新代码

组合语法:
非基本类型的对象:toString(),重写这个方法可以返回一个String对象
初始化引用的四种方式：
1.在定义对象的地方,在构造器被调用之前初始化
2.在类的构造器中
3.在正要使用这些对象之前,称为惰性初始化,可以减少额外的负担
4.使用实例初始化

继承语法:基类=父类=超类
如果子类重写了父类的某个方法,那么子类的对象调用的将是子类中重写的方法,父类的引用可指向子类的对象
初始化基类:
初始化类的时候,是从基类往外扩散的,也就是说先执行基类的构造器,再执行子类的构造器,即使你不为此类创建构造器,编译器也会默认为你合成一个构造器,并调用基类的构造器
带参数的构造器中,如果没有默认的构造器,或者想调用一个带参数的基类构造器,必须用关键字super
继承的顺序:静态优先,父类优先

代理:
java语言并没有提供对代理的直接支持,代理是继承和组合的中庸之道:
代理是new一个对象,然后在类中的方法调用这个对象的方法,相当于就多了一层
(继承是直接使用把父类方法占为己有,组合是new一个对象，然后去调用)

结合使用组合和继承:
在继承的同时,又new了其他类的对象
组合与继承之间的选择:
组合是显示的,继承是隐式的
is-a的关系是用继承来表达的
has-a的关系是则是用组合来表达的

向上转型:
用组合还是用继承,自问:是否需要从新类向基类进行向上转型,需要则继承


final关键字:
final意为无法改变的,不想改变会出于两种理由:设计或效率
final数据:
有时数据的恒定不变是很有用的:
一个永不改变的编译时常量;
一个在运行时被初始化的值,而你不希望它被改变
public static final是一种常用方式
public表示可以被用于包外,static强调只有一份,final说明它是一个常量
空白final:
Java允许空白final,无论如何编译器都要确保空白final在使用前被初始化,在定义处或者构造器中初始化
final参数:
意味着你无法在方法中更改参数引用所指向的对象,这一特性主要用来向匿名内部类传递数据
final方法:
使用final方法的原因有两个:
把方法锁定,以防止任何继承类修改它的含义;
效率,之前可以消除方法调用的开销,现在的Java版本已经不再需要使用final方法来进行优化
final和private关键字:
类中所有的private方法都隐式地指定为是final的,给private方法加final没有任何的意义
如果去重写private方法,并没有覆盖,而是生成了一个新的方法
final类:
将某个类的整体定义为final时,表示你打算继承这个类了,也不允许别人这样做,不希望它有子类
final类中所有的方法都隐式指定为是final的,因为无法覆盖它们

继承与初始化：
每个类的编译代码都存在于它自己的独立文件中,该文件只在需要使用的时候才会被加载
一般来说类的代码在初次使用的时候才加载,创建类的第一个对象时,或者访问static域或static方法时
static只会被初始化一次
